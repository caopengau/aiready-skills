/**
 * Consistency command - Check naming conventions and architectural consistency
 */

import chalk from 'chalk';
import { writeFileSync } from 'fs';
import { resolve as resolvePath } from 'path';
import { 
  loadMergedConfig, 
  handleJSONOutput, 
  handleCLIError, 
  getElapsedTime, 
  resolveOutputPath,
  formatToolScore,
} from '@aiready/core';
import type { ToolScoringOutput } from '@aiready/core';
import { getReportTimestamp, generateMarkdownReport } from '../utils/helpers';

interface ConsistencyOptions {
  naming?: boolean;
  patterns?: boolean;
  minSeverity?: string;
  include?: string;
  exclude?: string;
  output?: string;
  outputFile?: string;
  score?: boolean;
}

export async function consistencyAction(directory: string, options: ConsistencyOptions) {
  console.log(chalk.blue('ðŸ” Analyzing consistency...\n'));

  const startTime = Date.now();
  const resolvedDir = resolvePath(process.cwd(), directory || '.');

  try {
    // Define defaults
    const defaults = {
      checkNaming: true,
      checkPatterns: true,
      minSeverity: 'info' as const,
      include: undefined,
      exclude: undefined,
      output: {
        format: 'console',
        file: undefined,
      },
    };

    // Load and merge config with CLI options
    const finalOptions = await loadMergedConfig(resolvedDir, defaults, {
      checkNaming: options.naming !== false,
      checkPatterns: options.patterns !== false,
      minSeverity: options.minSeverity,
      include: options.include?.split(','),
      exclude: options.exclude?.split(','),
    });

    const { analyzeConsistency, calculateConsistencyScore } = await import('@aiready/consistency');

    const report = await analyzeConsistency(finalOptions);

    const elapsedTime = getElapsedTime(startTime);
    
    // Calculate score if requested
    let consistencyScore: ToolScoringOutput | undefined;
    if (options.score) {
      const issues = report.results?.flatMap((r: any) => r.issues) || [];
      consistencyScore = calculateConsistencyScore(issues, report.summary.filesAnalyzed);
    }

    const outputFormat = options.output || finalOptions.output?.format || 'console';
    const userOutputFile = options.outputFile || finalOptions.output?.file;

    if (outputFormat === 'json') {
      const outputData = {
        ...report,
        summary: {
          ...report.summary,
          executionTime: parseFloat(elapsedTime),
        },
        ...(consistencyScore && { scoring: consistencyScore }),
      };

      const outputPath = resolveOutputPath(
        userOutputFile,
        `aiready-report-${getReportTimestamp()}.json`,
        resolvedDir
      );
      
      handleJSONOutput(outputData, outputPath, `âœ… Results saved to ${outputPath}`);
    } else if (outputFormat === 'markdown') {
      // Markdown output
      const markdown = generateMarkdownReport(report, elapsedTime);
      const outputPath = resolveOutputPath(
        userOutputFile,
        `aiready-report-${getReportTimestamp()}.md`,
        resolvedDir
      );
      writeFileSync(outputPath, markdown);
      console.log(chalk.green(`âœ… Report saved to ${outputPath}`));
    } else {
      // Console output - format to match standalone CLI
      console.log(chalk.bold('\nðŸ“Š Summary\n'));
      console.log(`Files Analyzed: ${chalk.cyan(report.summary.filesAnalyzed)}`);
      console.log(`Total Issues: ${chalk.yellow(report.summary.totalIssues)}`);
      console.log(`  Naming: ${chalk.yellow(report.summary.namingIssues)}`);
      console.log(`  Patterns: ${chalk.yellow(report.summary.patternIssues)}`);
      console.log(`  Architecture: ${chalk.yellow(report.summary.architectureIssues || 0)}`);
      console.log(`Analysis Time: ${chalk.gray(elapsedTime + 's')}\n`);

      if (report.summary.totalIssues === 0) {
        console.log(chalk.green('âœ¨ No consistency issues found! Your codebase is well-maintained.\n'));
      } else {
        // Group and display issues by category
        const namingResults = report.results.filter((r: any) =>
          r.issues.some((i: any) => i.category === 'naming')
        );
        const patternResults = report.results.filter((r: any) =>
          r.issues.some((i: any) => i.category === 'patterns')
        );

        if (namingResults.length > 0) {
          console.log(chalk.bold('ðŸ·ï¸  Naming Issues\n'));
          let shown = 0;
          for (const result of namingResults) {
            if (shown >= 5) break;
            for (const issue of result.issues) {
              if (shown >= 5) break;
              const severityColor = issue.severity === 'critical' ? chalk.red :
                issue.severity === 'major' ? chalk.yellow :
                issue.severity === 'minor' ? chalk.blue : chalk.gray;
              console.log(`${severityColor(issue.severity.toUpperCase())} ${chalk.dim(`${issue.location.file}:${issue.location.line}`)}`);
              console.log(`  ${issue.message}`);
              if (issue.suggestion) {
                console.log(`  ${chalk.dim('â†’')} ${chalk.italic(issue.suggestion)}`);
              }
              console.log();
              shown++;
            }
          }
          const remaining = namingResults.reduce((sum, r) => sum + r.issues.length, 0) - shown;
          if (remaining > 0) {
            console.log(chalk.dim(`  ... and ${remaining} more issues\n`));
          }
        }

        if (patternResults.length > 0) {
          console.log(chalk.bold('ðŸ”„ Pattern Issues\n'));
          let shown = 0;
          for (const result of patternResults) {
            if (shown >= 5) break;
            for (const issue of result.issues) {
              if (shown >= 5) break;
              const severityColor = issue.severity === 'critical' ? chalk.red :
                issue.severity === 'major' ? chalk.yellow :
                issue.severity === 'minor' ? chalk.blue : chalk.gray;
              console.log(`${severityColor(issue.severity.toUpperCase())} ${chalk.dim(`${issue.location.file}:${issue.location.line}`)}`);
              console.log(`  ${issue.message}`);
              if (issue.suggestion) {
                console.log(`  ${chalk.dim('â†’')} ${chalk.italic(issue.suggestion)}`);
              }
              console.log();
              shown++;
            }
          }
          const remaining = patternResults.reduce((sum, r) => sum + r.issues.length, 0) - shown;
          if (remaining > 0) {
            console.log(chalk.dim(`  ... and ${remaining} more issues\n`));
          }
        }

        if (report.recommendations.length > 0) {
          console.log(chalk.bold('ðŸ’¡ Recommendations\n'));
          report.recommendations.forEach((rec: string, i: number) => {
            console.log(`${i + 1}. ${rec}`);
          });
          console.log();
        }
      }
      
      // Display score if calculated
      if (consistencyScore) {
        console.log(chalk.bold('\nðŸ“Š AI Readiness Score (Consistency)\n'));
        console.log(formatToolScore(consistencyScore));
        console.log();
      }
    }
  } catch (error) {
    handleCLIError(error, 'Consistency analysis');
  }
}